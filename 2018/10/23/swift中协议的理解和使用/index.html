<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="keep to run"><title>swift中协议的理解和使用 | Run</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">swift中协议的理解和使用</h1><a id="logo" href="/.">Run</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">swift中协议的理解和使用</h1><div class="post-meta">Oct 23, 2018<span> | </span><span class="category"><a href="/categories/swift/">swift</a></span></div><div class="post-content"><h3 id="POP-和-OOP-的对比"><a href="#POP-和-OOP-的对比" class="headerlink" title="POP 和 OOP 的对比"></a>POP 和 OOP 的对比</h3><p>面向对象编程–OOP, 即 Object Oriented Program</p>
<blockquote>
<p>面向对象编程–Object Oriented Programming, 简称OOP, 是一种程序设计思想. OOP把对象座位程序的集疤痕单元, 一个对象包含了数据和操作数据的函数</p>
</blockquote>
<a id="more"></a>
<p>传统的程序设计主张将程序看作一系列函数的集合, 或者直接就是一系列对计算机下大的指令. 面向对象程序设计中的每一个对象都应该能够接受数据,处理数据并将数据传达给其他面向对象, 因此它们都可以被看作一个小型的”机器”, 即对象.</p>
<p>面向对象编程具有继承, 封装, 多态, 抽象等特点.</p>
<p>而POP, 为面向协议编程. 是一个以协议为核心的编程方式. 协议集中表达了某一个特性或者功能. 它利用组合的特性可以更好的实现代码的组织.</p>
<p>iOS中, OOP是单继承, 而POP可以理解为多继承</p>
<p>由于OOP的工作方式, 它最好是单继承的, 因为多继承会让代码变得混乱.</p>
<p>当我们创建了比较大的类的继承链, 大量的属性或者方法会被继承. 当有新的需求或者特性的时候, 开发者通常会向继承链的根类(或者靠近根部的祖先)中添加新特性, 由于非常多的可能并不有用的特性而变得非常臃肿. 对应的子类型会继承这些并不需要的特性.  </p>
<p>这些OOP关注的点并不是写在一起的. 一个好的开发者需要避开上面的问题. 这可能需要花时间去经历. 比如说, 开发者客服这些功能性臃肿的问题, 通过添加其他类型的实例作为属性而不是从其它的类中继承过来. 这也是多用组合, 少用继承的思想.</p>
<p>Protocol是面向协议编程中非常关键的因素. 在Java, C# 等语言上都有接口的观念. iOS中的Protocol 非常像这些语言的接口, 但又不是完全一样. 这些Interface 以及OC 中的Protocol 什么都没有实现, 它只是声明了要满足的条件, 像是描述了一个蓝图. </p>
<p>OC明确下来, 使用Protocol来代替接口 interface, Protocol 可以获取方法和属性, 但是只有class 能够实现Protocol, struct 不可以.</p>
<h3 id="Swift是POP语言"><a href="#Swift是POP语言" class="headerlink" title="Swift是POP语言"></a>Swift是POP语言</h3><p>swift是以协议为基础发展起来的. 标准库中有50多个复杂不已的协议, 几乎所有的实际类型都是实现了若干协议的. 它是以协议为基础组织和建立起来的. 折合我们平时所知的面向对象的方式很不一样.<br>在swift之前, Protocol在OC中也是非常重要的. 但是与OC中的协议相比, 有了长足的进步. 总结下来:  </p>
<ol>
<li>swift中的值类型和引用类型都可以使用</li>
<li>swift中实现了一些和其他语言都不支持的特性</li>
</ol>
<h4 id="swift中值类型和引用类型"><a href="#swift中值类型和引用类型" class="headerlink" title="swift中值类型和引用类型"></a>swift中值类型和引用类型</h4><p>在OC中只有class才能够实现协议, 但是swift中不同.<br>swift中对值类型进行了优化, 引入 copy-on-write 机制, 使得值类型只有在被修改的时候才会执行copy操作, 大大提升了性能. 这在很大程度上弱化了引用类型的存在意义. 因此在swift中, 很大一部分的数据结构都改为了值类型机制实现, 包括string, array等. 此外swift中使用最为普遍的class, Struct, enum, 只有class为引用类型, 其余为值类型实现.<br>引用类型在使用上可能存在一定副作用, 一个引用被分享后, 很可能被不可预料的修改. 值类型很好的避免了这个问题.  </p>
<h4 id="swift中Protocol的特性–Extension"><a href="#swift中Protocol的特性–Extension" class="headerlink" title="swift中Protocol的特性–Extension"></a>swift中Protocol的特性–Extension</h4><blockquote>
<p>协议可以通过扩展提供方法, 初始化方法, 下标以及对应类型的计算属性. 这使得你可以通过协议来约定一些具体的行为, 而不是设置全局的方法或者在具体的某个类中分别进行实现  </p>
<p>通过协议的扩展, 所有遵循协议的类型都会自动获取扩展中实现的方法  </p>
<p>可以使用通过协议的扩展提供方法或计算属性的默认实现. 如果一个实现协议的类型提供了对应的方法或者属性, 则类型中具体的实现会取代默认的实现</p>
</blockquote>
<h3 id="举例-UITableViewCell-的注册与获取"><a href="#举例-UITableViewCell-的注册与获取" class="headerlink" title="举例 UITableViewCell 的注册与获取"></a>举例 UITableViewCell 的注册与获取</h3><h4 id="最传统的使用方式"><a href="#最传统的使用方式" class="headerlink" title="最传统的使用方式"></a>最传统的使用方式</h4><p>通常，我们在使用 UITableViewCell 或者 UICollectionViewCell 时， 要将对应的 cell 注册在 UITableView 或者 UICollectionView 中， 如下方代码所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let identifier: String = &quot;DemoTableViewCell&quot;</span><br><span class="line">//注册</span><br><span class="line">tableView.register(DemoTableViewCell.self, forCellReuseIdentifier: identifier)</span><br><span class="line"></span><br><span class="line">//获取</span><br><span class="line">let cell = tableView.dequeueReusableCell(withIdentifier:identifier, for: indexPath) as! DemoTableViewCell</span><br></pre></td></tr></table></figure>
<p>这是使用上最基本的流程， 如果对于获取 cell 时使用的强制类型转换抱有担心， 可以只用as?</p>
<h4 id="进一步的使用方式"><a href="#进一步的使用方式" class="headerlink" title="进一步的使用方式"></a>进一步的使用方式</h4><p>在具体的 ViewController 设置 cell 对应的标识符identifier是非常不好的。因为当前 ViewController 可能有多个 cell，一一指定是很杂的。 另外一个问题是， 当前的 UITableViewCell 可能在多个 ViewController 中进行复用， 如果没有 ViewController 中都进行这个的标识， 也是非常费事费力的。<br>因此，进一步的实现是， 我们把每个 cell 对应的标识符设置在 cell 的声明文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//声明</span><br><span class="line">class DemoTableViewCell: UITableViewCell &#123;</span><br><span class="line">    static let identifier: String = &quot;DemoTableViewCell&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注册</span><br><span class="line">tableView.register(DemoTableViewCell.self, forCellReuseIdentifier: DemoTableViewCell)</span><br><span class="line"></span><br><span class="line">//获取</span><br><span class="line">let cell = tableView.dequeueReusableCell(withIdentifier:DemoTableViewCell.identifier, for: indexPath) as! DemoTableViewCell</span><br></pre></td></tr></table></figure>
<p>如此，则避免了 identifier 的多处声明。 通常在 OC 的代码中，类似的方式就到此为止了。<br>但是在 tableView 注册 cell 以及 获取 cell 的过程中，每次方法的调用都使用了两次 cell 这个类，这样做是有些冗余的， 毕竟 Swift 中，泛型与协议也是非常强大的。类似的场景，我们可以传入一个类， 而获取类似的效果。</p>
<h4 id="在场景中引入-Protocol"><a href="#在场景中引入-Protocol" class="headerlink" title="在场景中引入 Protocol"></a>在场景中引入 Protocol</h4><p>我们可以默认实现一个协议，协议要求制定一个计算属性，默认返回类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol Reusable: class &#123;</span><br><span class="line"> static let identifier: String &#123;get&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Reusable &#123;</span><br><span class="line">    static let identifier: String &#123;</span><br><span class="line">        return String(describing: self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，只要对应的类实现协议Reusable，则默认会继承协议的默认方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extension UITableViewCell: Reusable &#123;&#125;</span><br><span class="line">extension UICollectionViewCell: Reusable &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下， 对于所有的UITableViewCell, UICollectionCell的相应子类则会默认拥有identifier这个属性，而不需要每次手动进行制定。确实快捷了许多。</p>
<h4 id="在场景中引入泛型"><a href="#在场景中引入泛型" class="headerlink" title="在场景中引入泛型"></a>在场景中引入泛型</h4><p>上面协议的引入，解决了identifier 在每次 UITableViewCell 进行声明时手动创建的问题，那么对于每次 cell 的注册与获取时，如何把两次类型的手动输入进行缩减呢？ 这里就需要用到泛型了。<br>不得不说，泛型是一个非常强大的功能。它一定程度上大大缩减了代码的书写复杂度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extension UITableView &#123;</span><br><span class="line">    //注册</span><br><span class="line">    func register&lt;T: UITableViewCell&gt;(_: T.Type)&#123;</span><br><span class="line">        register(T.self, forCellReuseIdentifier: T.reuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //获取</span><br><span class="line">     func dequeueReusableCell&lt;T: UITableViewCell&gt;(for indexPath: IndexPath) -&gt; T &#123;</span><br><span class="line">        if let cell = dequeueReusableCell(withIdentifier: T.reuseIdentifier, for: indexPath) as? T &#123;</span><br><span class="line">            return cell</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            fatalError(&quot;The dequeueReusableCell \(String(describing: T.self)) couldn&apos;t be loaded.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用过实现 UITableView 的扩展，新增两个对于regisiter与dequeueReusableCell进行增强的函数，引入泛型， 最终实现，输入一次参数的结果。 下面是具体的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//注册</span><br><span class="line">tableView.register(DemoTableViewCell.self)</span><br><span class="line"></span><br><span class="line">//获取</span><br><span class="line">let cell: DemoTableViewCell = tableView.dequeueReusableCell(indexPath: indexPath) // 用过泛型，直接可以输出对应的类型</span><br></pre></td></tr></table></figure>
<p>最终得到的效果是，tableView 中register与dequeueReusableCell方法，只需要输入需要的类型，就能够得到想要得到的结果，不仅在书写上大大的提速，而且在整洁性上有了极大的提升。<br>尤其是在泛型的使用过程中，let cell: DemoTableViewCell = tableView.dequeueReusableCell(indexPath: indexPath) 通过在方法指定返回类型，进一步推断方法内部要转的方法，这也是编译器”强大”的一个体现。</p>
<p>demo写到这里，已经非常的简洁了，但是还有一个问题是，通常注册 UITableViewCell 有两种途径： 通过 nib 或者 class。 上述讲到的，都是通过注册 class 来进行创建的， 那么nib 这种方式是如何创建的呢?</p>
<h4 id="如何使用nib进行创建"><a href="#如何使用nib进行创建" class="headerlink" title="如何使用nib进行创建"></a>如何使用nib进行创建</h4><p>对于nib的创建与注册，我们也可是实现类似protocol 默认方法 的方式来进行实现。<br>首先我们要做的是， 创建 nib 相关协议的实现。 NibLoadable默认实现了，通过类名来获取 nib实例的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol NibLoadable &#123;</span><br><span class="line"> static var nib: UINib &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension NibLoadable &#123;</span><br><span class="line">    </span><br><span class="line">    static var nib: UINib &#123;</span><br><span class="line">        return UINib(nibName: String(describing: self), bundle: Bundle(for: self))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，并非所有的 UIView 或者 UITableViewCell 都是可以通过nib 进行获取的，因此我们要有选择的对其进行实现。 这里就需要开发者手动指定是否要实现NibLoadable 这个协议了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DemoNibTableViewCell: UITableViewCell, NibLoadable &#123;</span><br><span class="line">  </span><br><span class="line">    override func awakeFromNib() &#123;</span><br><span class="line">        super.awakeFromNib()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于需要通过.xib进行创建的cell， 我们需要手动继承NibLoadable提供的默认实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension UITableView &#123;</span><br><span class="line"> func register&lt;T: UITableViewCell&gt;(_: T.Type) where T: NibLoadable &#123;</span><br><span class="line">        register(T.nib, forCellReuseIdentifier: T.reuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，与上文中实现的register方法不同，此处实现的方法通过where进行了类型限定。<br>要求传入的参数要满足的两个条件 1. 是 UITableViewCell的子类 2. 实现 NibLoadable 协议。  </p>
<p>现在我们把两个方法放在一起进行一下对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func register&lt;T: UITableViewCell&gt;(_: T.Type) where T: NibLoadable &#123;</span><br><span class="line">        register(T.nib, forCellReuseIdentifier: T.reuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">func register&lt;T: UITableViewCell&gt;(_: T.Type)&#123;</span><br><span class="line">        register(T.self, forCellReuseIdentifier: T.reuseIdentifier)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>两者看起来，在方法调用时几乎看不出区别，但是在具体调用时却会走不同的方法。 唯一的区别就是 nibLoadable 的方法要求的参数更加严格一点， 我们也可以看出， 第一个方法的参数是第二个方法参数的”子集”.  </p>
<p>那么我们来看一下具体的调用场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView.register(DemoTableViewCell.self) //通过 UITableViewCell.class 进行创建</span><br><span class="line">tableView.register(DemoNibTableViewCell.self) //通过nib 进行创建。</span><br></pre></td></tr></table></figure>
<p>通过上面的例子我们可以看到，在做好了底层的工作之后，tableView 进行 cell 注册时， 开发者几乎不需要区分具体的 cell 是通过 nib 创建还是通过 class 创建。 这也是一个生产力！ 唯一需要注意的就是，在实现UITableViewCell时， 要有针对性的添加 NibLoadable 这个协议， 获取其默认实现。 这相对于传统的方法已经是一个成本低得多的方案。</p>
<p>参考:<br><a href="https://www.jianshu.com/p/255e02337176" target="_blank" rel="noopener">swift标配开源库：Reusable-让你放肆的dequeueReusableCell</a><br><a href="https://juejin.im/entry/589439622f301e00693567e5#comment" target="_blank" rel="noopener">Swift 面向协议编程入门</a><br><a href="https://academy.realm.io/cn/posts/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/" target="_blank" rel="noopener">真刀真枪 面向协议编程</a><br><a href="https://onevcat.com/2016/11/pop-cocoa-1/" target="_blank" rel="noopener">面向协议编程与 Cocoa 的邂逅 (上)</a><br><a href="https://onevcat.com/2016/12/pop-cocoa-2/" target="_blank" rel="noopener">面向协议编程与 Cocoa 的邂逅 (下)</a></p>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<!--more-->
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
</div><div class="tags"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">swift</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/swift中协议的理解和使用/">swift中协议的理解和使用</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Run.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>